# CGI 아키텍처 다이어그램

<img width="361" alt="스크린샷 2023-04-01 20 28 17" src="https://user-images.githubusercontent.com/76278794/229286069-17e194f8-b556-4d35-bc87-120abb7282e1.png">

<br>

# CGI란?

- Common Gateway Interface는 web server와 custom script 간 정보 교환 방식을 정의하는 표준이다.
- CGI spec는 NCSA가 유지보수하며 NCSA가 CGI를 정의한다.
- CGI(Common Gateway Interface)는 외부 게이트웨이 프로그램이 HTTP 서버와 같은 정보 서버와 인터페이스하기 위한 표준입니다.

# Web server 설정

- CGI 프로그래밍을 계속하기 전에 웹 서버가 CGI를 지원하고 CGI 프로그램을 처리하도록 구성되어 있는지 확인하십시오.
- HTTP 서버에서 실행할 모든 CGI 프로그램은 사전 구성된 디렉토리에 보관됩니다.
- 이 디렉터리는 CGI 디렉터리라고 하며 관례에 따라 /var/www/cgi-bin으로 이름이 지정됩니다.
- CGI 파일은 C++ 실행 파일이지만 .cgi로 확장된다.
- 기본적으로 Apache Web 서버는 /var/www/cgi-bin에서 CGI 프로그램을 실행하도록 구성되어 있습니다.
- CGI 스크립트를 실행할 다른 디렉터리를 지정하려면 httpd.conf 파일에서 다음 섹션을 수정할 수 있습니다

```cpp
<Directory "/var/www/cgi-bin">
   AllowOverride None
   Options ExecCGI
   Order allow,deny
   Allow from all
</Directory>

<Directory "/var/www/cgi-bin">
   Options All
</Directory>
```

# CGI by CPP

- c++로 작성된 이런 프로그램도 CGI가 될 수 있습니다.

```cpp
#include <iostream>
using namespace std;

int main () {
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>Hello World - First CGI Program</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<h2>Hello World! This is my first CGI program</h2>\n";
   cout << "</body>\n";
   cout << "</html>\n";

   return 0;
}
```

<br><br>


# RFC 3875

# Intro

## 1.1. 목적

- 공통 게이트웨이 인터페이스 (CGI) [22]는 HTTP [1], [4] 서버와 CGI 스크립트가 클라이언트 요청에 대해 책임을 공유할 수 있도록 합니다. 
- 클라이언트 요청은 통신 프로토콜에서 제공하는 Uniform Resource Identifier (URI) [11], 요청 메서드 및 기타 보조 정보로 구성됩니다.

- CGI는 클라이언트 요청을 설명하는 `메타 변수라고하는 추상 매개 변수`를 정의합니다. 
- 이와 함께 구체적인 프로그래머 인터페이스가 있어 스크립트와 HTTP 서버 간에 플랫폼 독립적인 인터페이스를 지정합니다.

- 서버는 클라이언트 요청과 관련된 `연결, 데이터 전송, 전송 및 네트워크 문제를 관리하는 책임`이 있으며, 
	- CGI 스크립트는 데이터 접근 및 문서 처리와 같은 응용 프로그램 문제를 처리합니다.

<br>

## 1.2. 요구 사항

- 이 문서에서 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY' 및 'OPTIONAL'이라는 키워드는 BCP 14, RFC 2119 [3]에 설명된대로 해석되어야 합니다.

- 프로토콜을 구현하는 경우 'must' 요구 사항 중 하나 이상을 충족하지 못하면 구현이 규정에 준하지 않습니다. 
- 기능의 모든 'must' 및 'should' 요구 사항을 충족하는 구현은 '무조건 준수'라고합니다. 
- 'must' 요구 사항을 모두 충족하지만 기능의 'should' 요구 사항을 모두 충족하지 못하는 구현은 '조건부 준수'라고합니다.

<br>

## 1.3 사양

- CGI의 모든 기능과 기능이 이 `사양의 주요 부분에서 정의되지는 않습니다.`

- 다음 구문은 지정되지 않은 기능을 설명하는 데 사용됩니다:
	1. 'system-defined' (시스템 정의)
		- 이 기능은 시스템 간에 다를 수 있지만, 동일한 시스템을 사용하는 다른 구현에서는 동일해야 합니다. 
		- 일반적으로 시스템은 운영 체제 클래스를 식별합니다. 일부 시스템은 이 문서의 섹션 7에서 정의됩니다. 
		- 새로운 시스템은 이 문서를 수정하지 않고 새로운 사양에 의해 정의될 수 있습니다.

	2. 'implementation-defined' (구현 정의)
		- 이 기능의 동작은 구현에 따라 다를 수 있으며, 특정 구현은 동작을 문서화해야 합니다.

<br>

## 1.4. 용어

1. 'meta-variable' (메타 변수)
	- 서버에서 스크립트로 정보를 전달하는 이름이 지정된 매개 변수입니다. 이는 운영 체제 환경의 변수일 필요는 없지만, 가장 일반적인 구현 방식입니다.

2. 'script' (스크립트)
	- 이 인터페이스에 따라 서버에 의해 호출되는 소프트웨어입니다. 
	- `단독 프로그램이 아니어도 되며, 동적으로 로드되거나 공유 라이브러리이거나 심지어 서버의 하위 루틴`일 수도 있습니다. 
	- `스크립트는 실행 시간에 해석되는 문장 집합일 수 있으며, '스크립트'라는 용어는 종종 이해되지만 이는 요구 사항은 아니며, 이 사양의 문맥에서는 보다 넓은 정의가 적용됩니다.`

3. 'server' (서버)
	- 클라이언트의 요청을 처리하기 위해 스크립트를 호출하는 응용 프로그램입니다.

<br><br>

# 2. BNF 생략

<br><br>

# 3. 스크립트 호출

## 3.1. 서버의 책임

- 서버는 응용 프로그램 게이트웨이로 작동합니다. 

1. 클라이언트로부터 요청을 받아들이고, 
2. 요청을 처리하기 위해 CGI 스크립트를 선택하고, 
3. 클라이언트 요청을 CGI 요청으로 변환하며, 
4. 스크립트를 실행하고, 
5. CGI 응답을 클라이언트에 대한 응답으로 변환합니다. 

- 클라이언트 요청을 처리하는 동안, 서버는 `프로토콜(응용계층)이나 전송 수준(tcp, udp계층)의 인증 및 보안을 구현하는 책임`이 있습니다. 
- 서버는 또한 '비투명(non-transparent)'한 방식으로 작동하여 요청이나 응답을 수정하여 미디어 유형 변환이나 프로토콜 축소와 같은 추가 서비스를 제공할 수 있습니다.



- 서버는 이 사양에서 요구하는 클라이언트 요청 데이터에 대한 변환 및 프로토콜 변환을 수행해야 합니다. 
- 또한, CGI 스크립트가 이 사양을 준수하지 않는 경우에도 서버는 관련 네트워크 프로토콜에 대한 책임을 클라이언트에게 지속해야 합니다.

- 서버가 요청에 인증을 적용하는 경우, 모든 정의된 액세스 제어를 통과하지 않는 한 스크립트를 실행해서는 안 됩니다.

<br>

## 3.2. 스크립트 선택

- 서버는 클라이언트가 제공한 범용 형식 URI에 기반하여 실행할 CGI 스크립트를 결정합니다. 
- 이 URI에는 "/"로 구분된 구조적 경로가 포함됩니다. 특정 요청에 대해, 서버는 경로의 일부 또는 전체를 개별 스크립트와 일치시켜 경로 계층 구조의 특정 지점에 스크립트를 배치합니다. 
- `경로의 나머지 부분`(있는 경우)은 스크립트에 의해 해석되어야 하는 `리소스 또는 하위 리소스` 식별자입니다.

- 이 경로 분할에 대한 정보는 아래에 설명된 메타 변수를 통해 스크립트에서 사용할 수 있습니다. 
- `비계층적인 URI 스킴에 대한 지원은 이 사양의 범위를 벗어납니다.`

<br>

## 3.3. 스크립트-URI

- 클라이언트 요청 URI에서 스크립트 선택까지의 매핑은 특정 서버 구현과 해당 구성에 의해 정의됩니다. 
- 서버는 스크립트를 여러 개의 다른 URI 경로 계층 구조로 식별할 수 있게 하고, 따라서 처리 및 메타 변수 생성 중에 이러한 집합의 다른 멤버로 URI를 대체할 수 있습니다. 
- 서버는 다음 중 하나를 선택하여 URI를 처리할 수 있습니다.

  1. 특정 클라이언트 요청에서 URI를 보존할 수 있습니다.

  2. 각 스크립트에 대한 가능한 값 집합에서 정규화된 URI를 선택할 수 있습니다.

  3. 다른 URI 선택 방법을 구현할 수 있습니다.


- 이렇게 생성된 메타 변수를 기반으로 '스크립트-URI'라는 URI를 생성할 수 있습니다.
- 이 URI는 클라이언트가 이 URI에 접근했다면 스크립트가 SCRIPT_NAME, PATH_INFO 및 QUERY_STRING 메타 변수에 대해 동일한 값을 가지고 실행되었을 것이라는 속성을 가져야 합니다. 
- 스크립트-URI는 RFC 2396 [2]의 섹션 3에서 정의된 일반적인 URI의 구조를 가지며, 객체 매개 변수 및 단편 식별자는 허용되지 않습니다. 
- 스크립트-URI의 다양한 구성 요소는 일부 메타 변수에 의해 정의됩니다 (아래 참조).

```
  script-URI = <scheme> "://" <server-name> ":" <server-port>
               <script-path> <extra-path> "?" <query-string>
```

- 여기서 \<scheme\>은 SERVER_PROTOCOL에서 얻어지고, \<server-name\>, \<server-port\> 및 \<query-string\>은 해당하는 메타 변수의 값입니다. 
- SCRIPT_NAME 및 PATH_INFO 값은 `";", "=", "?"`와 함께 URL 인코딩되어 \<script-path\> 및 \<extra-path\>를 제공합니다.


- 스킴과 프로토콜은 동일하지 않습니다. 
- 스킴은 응용 프로토콜 외에도 액세스 방법을 식별합니다. 
- 예를 들어, `HTTP 프로토콜 [19]을 사용할 때, Transport Layer Security (TLS) [14]를 사용하여 액세스되는 리소스는 스킴이 https인 요청 URI를 갖습니다.` 
- CGI/1.1은 스크립트가 이를 재구성하는 일반적인 수단을 제공하지 않으므로, 정의된대로 스크립트-URI에는 사용된 기본 프로토콜이 포함됩니다. 
- 그러나 스크립트는 스킴별 메타 변수를 사용하여 URI 스킴을 더 잘 추론할 수 있습니다.

- 또한, 이 정의는 경로 정보나 쿼리 문자열에 대해 허용된 값으로 스크립트를 호출할 수 있는 URI를 생성할 수 있도록 합니다. 
- 이를 위해 적절한 구성 요소를 수정할 수 있습니다.


<br>

## 3.4 실행

- 스크립트는 시스템에서 정의한 방식으로 호출됩니다. 
- `별도로 지정되지 않은 경우, 스크립트가 포함된 파일은 실행 가능한 프로그램으로 호출`됩니다. 

1. 서버는 섹션 4에서 설명한대로 CGI 요청을 준비합니다. 
	- 이는 요청 메타 변수(스크립트가 실행될 때 즉시 사용 가능)와 요청 메시지 데이터로 구성됩니다. 
2. 요청 데이터는 스크립트에 즉시 사용 가능할 필요는 없으며, 서버가 클라이언트로부터 이 데이터를 모두 수신하기 전에 스크립트가 실행될 수 있습니다. 
3. 스크립트의 응답은 섹션 5와 6에서 설명한 대로 서버로 반환됩니다.

- 오류 상황이 발생할 경우, 서버는 언제든지 경고 없이 스크립트 실행을 중단하거나 종료할 수 있습니다. 
- 이는 예를 들어 서버와 클라이언트 간의 전송 실패가 발생한 경우에 발생할 수 있습니다. 
- 따라서 스크립트는 비정상적인 종료를 처리할 수 있도록 준비되어야 합니다.

<br>
<br>

# 4. CGI 요청

- 요청에 대한 정보는 두 가지 다른 소스에서 제공됩니다. 
1. 요청 메타 변수
2. 관련된 메시지 본문.

<br>

## 4.1. 요청 메타 변수

- 메타 변수는 서버에서 스크립트로 전달되는 요청에 관한 데이터를 포함하며, 시스템에서 정의한 방식으로 스크립트에서 액세스됩니다. 
- 메타 변수는 대소문자를 구분하지 않는 이름으로 식별됩니다. 
- 대소문자만 다른 두 가지 다른 변수가 존재할 수 없습니다. 
- 여기에서는 대문자와 언더스코어("")를 사용하여 표시됩니다. 
- 특정 시스템은 다른 표현을 정의할 수 있습니다.

```
meta-variable-name = 
"AUTH_TYPE" | "CONTENT_LENGTH" |
"CONTENT_TYPE" | "GATEWAY_INTERFACE" |
"PATH_INFO" | "PATH_TRANSLATED" |
"QUERY_STRING" | "REMOTE_ADDR" |
"REMOTE_HOST" | "REMOTE_IDENT" |
"REMOTE_USER" | "REQUEST_METHOD" |
"SCRIPT_NAME" | "SERVER_NAME" |
"SERVER_PORT" | "SERVER_PROTOCOL" |
"SERVER_SOFTWARE" | scheme |
protocol-var-name | extension-var-name

protocol-var-name = ( protocol | scheme ) "" var-name

scheme = alpha *( alpha | digit | "+" | "-" | "." )

var-name = token

extension-var-name = token
```

- 스킴과 동일한 이름을 가진 메타 변수와 프로토콜이나 스킴 이름으로 시작하는 이름(HTTP_ACCEPT 등)도 정의됩니다. 
- 이러한 변수의 수와 의미는 이 사양과는 독립적으로 변경될 수 있습니다. (4.1.18 절도 참조하세요.)

- 서버는 "X_"로 접두사가 붙은 구현 정의된 확장 메타 변수를 추가로 설정할 수 있으며, 이러한 변수의 이름은 "X_"로 접두사를 붙여야 합니다.

- 이 사양은 길이가 0인 (NULL) 값과 값이 없는 경우를 구별하지 않습니다. 
- 예를 들어, 스크립트는 http://host/script와 http://host/script?의 두 요청을 구별할 수 없습니다. 이 두 경우 모두 QUERY_STRING 메타 변수는 NULL일 것입니다.

```
  meta-variable-value = "" | 1*<TEXT, CHAR or tokens of value>
```
- 선택적인 메타 변수는 값이 NULL인 경우 생략될 수 있습니다. 메타 변수 값은 그렇지 않은 한 대소문자를 구분해야 합니다. 
- 메타 변수의 문자 표현은 시스템에서 정의되며, 서버는 값을 해당 표현으로 변환해야 합니다.

<br>

### 4.1.1. AUTH_TYPE

- AUTH_TYPE 변수는 서버가 사용자를 인증하기 위해 사용하는 모든 메커니즘을 식별합니다. 
- 클라이언트 프로토콜이나 서버 구현에서 정의된 대소문자를 구분하지 않는 값을 포함합니다.

- HTTP의 경우, 클라이언트 요청이 외부 액세스를 위해 인증을 요구하는 경우, 서버는 이 변수의 값을 요청 Authorization 헤더 필드의 'auth-scheme' 토큰에서 설정해야 합니다.

```
  AUTH_TYPE      = "" | auth-scheme
  auth-scheme    = "Basic" | "Digest" | extension-auth
  extension-auth = token
```
HTTP 액세스 인증 방식에 대한 설명은 RFC 2617 [5]에서 제공됩니다.

<br>

### 4.1.2. CONTENT_LENGTH

- CONTENT_LENGTH 변수에는 요청에 첨부된 메시지 본문의 크기가 8진수로 표시됩니다. 
- 데이터가 첨부되지 않은 경우, NULL(또는 설정되지 않음)입니다.

```
  CONTENT_LENGTH = "" | 1*digit
```

- `서버는 요청이 메시지 본문 엔티티와 함께 전송되는 경우에만 이 메타 변수를 설정`해야 합니다. 
- `CONTENT_LENGTH 값은 서버가 모든 전송 인코딩 또는 콘텐트 인코딩을 제거한 후의 메시지 본문의 길이를 반영해야 합니다.`

<br>

### 4.1.3. CONTENT_TYPE

- 요청에 메시지 본문이 포함되어 있는 경우, CONTENT_TYPE 변수는 메시지 본문의 인터넷 미디어 타입 [6]으로 설정됩니다.

```
  CONTENT_TYPE = "" | media-type
  media-type   = type "/" subtype *( ";" parameter )
  type         = token
  subtype      = token
  parameter    = attribute "=" value
  attribute    = token
  value        = token | quoted-string
```

- 타입, 서브타입 및 매개변수 속성 이름은 대소문자를 구분하지 않습니다. 
- 매개변수 값은 대소문자를 구분할 수 있습니다. 
- 미디어 타입과 그들의 HTTP에서의 사용은 HTTP/1.1 사양의 섹션 3.7에서 설명되어 있습니다.

- 이 변수에 대한 기본값은 존재하지 않습니다. 
- 설정되지 않은 경우, 스크립트는 수신한 데이터에서 미디어 타입을 결정하려고 할 수 있습니다. 
- 타입이 알려지지 않은 경우, 스크립트는 application/octet-stream 유형을 가정하거나 오류로 요청을 거부할 수 있습니다 (6.3.3 절에서 설명).

- 각 미디어 타입은 선택적 및 필수 매개변수 세트를 정의합니다. 
- 이는 메시지 본문의 인코딩된 문자 집합을 정의하는 대소문자를 구분하지 않는 값을 가지는 charset 매개변수를 포함할 수 있습니다. 
- charset 매개변수가 생략된 경우, 다음 중 가장 먼저 적용되는 규칙에 따라 기본값이 유도되어야 합니다.

```
  1. 일부 미디어 유형에는 시스템 정의된 기본 문자 집합이 있을 수 있습니다.

  2. "text" 유형의 미디어 유형의 기본값은 ISO-8859-1 [4]입니다.

  3. 미디어 유형 사양에 정의된 기본값이 있을 수 있습니다.

  4. 기본값은 US-ASCII입니다.
```

- 서버는 클라이언트 요청 헤더에 HTTP Content-Type 필드가 있으면 이 메타 변수를 설정해야 합니다. 
- `서버가 첨부된 엔티티를 가진 요청을 받았지만 Content-Type 헤더 필드가 없는 경우, 올바른 콘텐츠 유형을 결정하려고 시도할 수 있으며, 그렇지 않은 경우 이 메타 변수를 생략해야 합니다.`

<br>

### 4.1.4. GATEWAY_INTERFACE

- GATEWAY_INTERFACE 변수는 서버가 스크립트와 통신하기 위해 사용하는 CGI의 방언을 설정해야 합니다. 구문은 다음과 같습니다.

```
  GATEWAY_INTERFACE = "CGI" "/" 1*digit "." 1*digit
```

- 주의해야 할 점은 주요 및 부 주요 숫자가 별도의 정수로 처리되어 각각 한 자리 숫자보다 크게 증가할 수 있다는 것입니다. 
- 따라서 CGI/2.4는 CGI/2.13보다 낮은 버전이며, 이는 다시 CGI/12.3보다 낮은 버전입니다. 
- 스크립트는 선행 0을 무시해야 하며, 서버에서 생성해서는 안됩니다.

- 이 문서는 CGI 인터페이스의 1.1 버전을 정의합니다.

<br>

### 4.1.5. PATH_INFO

- PATH_INFO 변수는 CGI 스크립트에 의해 해석되어야 하는 경로를 지정합니다. 
- 이는 스크립트 자체를 식별하는 부분 이후의 URI 경로 계층 구조에서 파생됩니다. 
- URI 경로와 달리 PATH_INFO는 URL-인코딩되지 않으며, 경로 세그먼트 매개변수를 포함할 수 없습니다. 
- PATH_INFO의 "/"는 단일 비어있는 경로 세그먼트를 나타냅니다.

```
  PATH_INFO = "" | ( "/" path )
  path      = lsegment *( "/" lsegment )
  lsegment  = *lchar
  lchar     = <any TEXT or CTL except "/">
  ```

- 이 값은 대소문자를 구분하며, 서버는 요청 URI에서 제시된 경로의 대소문자를 유지해야 합니다. 
- 서버는 PATH_INFO에 허용되는 값에 대한 제한과 제한을 부과할 수 있으며, 문제가 될 수 있는 값이 발견되면 오류로 요청을 거부할 수 있습니다. 
- 이는 PATH_INFO로 인코딩된 "/"가 디코딩되어 정보 손실을 스크립트에게 나타낼 수 있기 때문입니다. 
- 마찬가지로 경로의 비 US-ASCII 문자의 처리는 시스템에 따라 정의됩니다.

- URL-인코딩된 PATH_INFO 문자열은 Script-URI의 extra-path 구성 요소를 형성하며 (3.3 절 참조), SCRIPT_NAME 경로의 일부를 따릅니다.

<br>

###  4.1.6. PATH_TRANSLATED

- PATH_TRANSLATED 변수는 PATH_INFO 값을 가져와 해당 값을 자체적으로 로컬 URI로 구문 분석하고, 적절한 가상에서 물리적 변환을 수행하여 서버의 문서 저장소 구조에 매핑합니다. 
- 결과에 허용되는 문자 집합은 시스템에 따라 정의됩니다.

```
  PATH_TRANSLATED = *<any character>
```
- 이는 원래 클라이언트 요청의 스킴 및 서버 위치 및 URL-인코딩된 PATH_INFO를 사용하여 다음을 요청하는 파일 위치입니다.

```
  <scheme> "://" <server-name> ":" <server-port> <extra-path>
```

- 여기서 <scheme>은 원래 클라이언트 요청의 스킴이고, <extra-path>는 PATH_INFO의 URL-인코딩된 버전입니다. 
- ";", "=" 및 "?"는 예약되어 있습니다. 

- 예를 들어, 다음과 같은 요청에 대해:
```
  http://somehost.com/cgi-bin/somescript/this%2eis%2epath%3binfo
```

- PATH_INFO 값은 다음과 같습니다.

```
  /this.is.the.path;info
```

스킴, 서버 위치 및 URL-인코딩된 PATH_INFO로부터 내부 URI가 구성됩니다.

```
  http://somehost.com/this.is.the.path%3binfo
```

이는 서버의 문서 저장소에서 위치로 변환될 수 있습니다. 예를 들어 다음과 같은 파일 시스템 경로입니다.

```
  /usr/local/www/htdocs/this.is.the.path;info
```

- PATH_TRANSLATED의 값은 이러한 변환의 결과입니다.

- 이러한 방식으로 값을 파생시키는 동안, 유효한 저장소 위치로 매핑되지 않더라도 값을 파생시킵니다. 
- 서버는 extra-path 세그먼트의 대소문자를 유지하지 않아도 되며, 기반이 되는 저장소가 대소문자를 구분하는 경우에도 원래 세그먼트의 대소문자를 유지할 필요는 없습니다.

- 서버는 요청 URI에 경로 정보 구성 요소가 포함되어 있는 경우 이 메타 변수를 설정해야 합니다. 
- PATH_INFO가 NULL인 경우 PATH_TRANSLATED 변수는 NULL로 설정해야 합니다 (또는 unset).


<br>


### 4.1.8. REMOTE_ADDR

- REMOTE_ADDR 변수는 서버에 요청을 보내는 클라이언트의 네트워크 주소로 설정되어야 합니다.

```
  REMOTE_ADDR  = hostnumber
  hostnumber   = ipv4-address | ipv6-address
  ipv4-address = 1*3digit "." 1*3digit "." 1*3digit "." 1*3digit
  ipv6-address = hexpart [ ":" ipv4-address ]
  hexpart      = hexseq | ( [ hexseq ] "::" [ hexseq ] )
  hexseq       = 1*4hex *( ":" 1*4hex )
```

- IPv6 주소의 형식은 RFC 3513 [15]에서 설명되어 있습니다.

<br>

### 4.1.9. REMOTE_HOST

- REMOTE_HOST 변수는 클라이언트가 서버로 요청을 보내는 경우 사용 가능한 경우 클라이언트의 완전히 정규화된 도메인 이름을 포함하며, 그렇지 않은 경우 NULL입니다.- 완전히 정규화된 도메인 이름은 RFC 1034 [17]의 3.5절과 RFC 1123 [12]의 2.1절에 설명된 대로 형식을 가지고 있습니다. 
- 도메인 이름은 대소문자를 구분하지 않습니다.

```
  REMOTE_HOST   = "" | hostname | hostnumber
  hostname      = *( domainlabel "." ) toplabel [ "." ]
  domainlabel   = alphanum [ *alphahypdigit alphanum ]
  toplabel      = alpha [ *alphahypdigit alphanum ]
  alphahypdigit = alphanum | "-"
```

- 서버는 이 변수를 설정해야 합니다. 
- 호스트 이름이 성능상의 이유나 기타 이유로 사용할 수 없는 경우 서버는 REMOTE_ADDR 값을 대체할 수 있습니다.

<br>

### 4.1.10. REMOTE_IDENT


- REMOTE_IDENT 변수는 사용 가능한 경우 원격 에이전트에 대한 RFC 1413 [20] 요청으로 보고된 연결에 대한 신원 정보를 제공하기 위해 사용될 수 있습니다. 
- 서버는 이 기능을 지원하지 않거나 효율성을 위해 데이터를 요청하지 않거나 사용 가능한 신원 데이터를 반환하지 않도록 선택할 수 있습니다.

```
  REMOTE_IDENT = *TEXT
```

- 반환된 데이터는 인증 목적으로 사용될 수 있지만, 해당 데이터에 신뢰를 둘 수 있는 수준은 최소화되어야 합니다.

<br>

### 4.1.11. REMOTE_USER

- REMOTE_USER 변수는 클라이언트로부터 사용자 인증의 일부로 제공된 사용자 식별 문자열을 제공합니다.

```
  REMOTE_USER = *TEXT
```

- 클라이언트 요청이 HTTP 인증 [5]을 요구하는 경우 (예: AUTH_TYPE 메타 변수가 "Basic" 또는 "Digest"로 설정된 경우), `REMOTE_USER 메타 변수의 값은 제공된 사용자 ID로 설정되어야 합니다.`


<br>

### 4.1.12. REQUEST_METHOD

- REQUEST_METHOD 메타 변수는 스크립트가 요청을 처리하는 데 사용해야 하는 메서드로 설정되어야 합니다. 자세한 내용은 4.3절을 참조하십시오.

```
  REQUEST_METHOD   = method
  method           = "GET" | "POST" | "HEAD" | extension-method
  extension-method = "PUT" | "DELETE" | token
```

- 메서드는 대소문자를 구분합니다. HTTP 메서드는 HTTP/1.0 명세 [1]의 5.1.1절과 HTTP/1.1 명세 [4]의 5.1.1절에 설명되어 있습니다.

<br>

### 4.1.13. SCRIPT_NAME

- SCRIPT_NAME 변수는 CGI 스크립트 (스크립트의 출력이 아닌)를 식별할 수 있는 URI 경로 (URL 인코딩되지 않음)로 설정되어야 합니다. 
- 구문은 PATH_INFO (4.1.5절)과 동일합니다.

```
  SCRIPT_NAME = "" | ( "/" path )
```

- 선행하는 "/"는 경로의 일부가 아닙니다. 경로가 NULL인 경우 선택적입니다. 그러나 변수는 그 경우에도 설정되어야 합니다.

- SCRIPT_NAME 문자열은 일부 구현에 따라 생성된 Script-URI의 경로 구성 요소의 선행 부분을 형성합니다. 
- SCRIPT_NAME 값에는 PATH_INFO 세그먼트 (4.1.5절 참조)가 포함되지 않습니다.

<br>

### 4.1.14. SERVER_NAME


- SERVER_NAME 변수는 클라이언트 요청이 전달되는 서버 호스트의 이름으로 설정되어야 합니다. 
- 대소문자를 구분하지 않는 호스트 이름이나 네트워크 주소입니다. 
- 이 변수는 Script-URI의 호스트 부분을 형성합니다.

```
  SERVER_NAME = server-name
  server-name = hostname | ipv4-address | ( "[" ipv6-address "]" )
```

- 배포된 서버는 이 변수에 대해 여러 가능한 값을 가질 수 있으며, 여러 HTTP 가상 호스트가 동일한 IP 주소를 공유하는 경우입니다. 
- 이 경우 서버는 요청의 Host 헤더 필드 내용을 사용하여 올바른 가상 호스트를 선택합니다.

<br>

### 4.1.15. SERVER_PORT

- SERVER_PORT 변수는 이 요청을 클라이언트로부터 수신하는 TCP/IP 포트 번호로 설정되어야 합니다. 
- 이 값은 Script-URI의 포트 부분에 사용됩니다.

```
  SERVER_PORT = server-port
  server-port = 1*digit
```

- 이 변수는 포트가 스키마의 기본 포트인 경우에도 생략될 수 있지만, 스키마와 관련된 기본 포트여도 반드시 설정되어야 합니다.

<br>

### 4.1.16. SERVER_PROTOCOL

- SERVER_PROTOCOL 메타 변수는 CGI 요청에 사용되는 응용 프로토콜의 이름과 버전으로 설정되어야 합니다. 
- 이는 서버가 클라이언트와의 통신에서 사용하는 프로토콜 버전과 다를 수 있습니다.

```
  SERVER_PROTOCOL   = HTTP-Version | "INCLUDED" | extension-version
  HTTP-Version      = "HTTP" "/" 1*digit "." 1*digit
  extension-version = protocol [ "/" 1*digit "." 1*digit ]
  protocol          = token
```

- 여기서 'protocol'은 서버와 스크립트 간의 정보 교환 (프로토콜 특정 기능)의 구문을 정의합니다. 
- 대소문자를 구분하지 않으며 일반적으로 대문자로 표시됩니다. 
- 프로토콜은 스크립트 URI의 스키마 부분과 동일하지 않으며, 클라이언트가 "HTTP" 프로토콜을 사용하여 스크립트에 도달하는 요청은 "https" 스키마를 사용할 수 있습니다.


- 서버는 "INCLUDED"와 같은 서버 프로토콜의 잘 알려진 값 사용을 선택할 수 있으며, 이는 현재 문서가 클라이언트 요청의 직접 대상이 아닌 복합 문서의 일부로 포함된다는 것을 나타냅니다. 
- 스크립트는 이를 HTTP/1.0 요청으로 처리해야 합니다.

<br>

### 4.1.17. SERVER_SOFTWARE

- SERVER_SOFTWARE 메타 변수는 CGI 요청을 수행하는 정보 서버 소프트웨어의 이름과 버전으로 설정되어야 합니다. 
- (게이트웨이를 실행하는) 서버가 클라이언트에 보고하는 서버 설명과 동일해야 합니다.

```
  SERVER_SOFTWARE = 1*( product | comment )
  product         = token [ "/" product-version ]
  product-version = token
  comment         = "(" *( ctext | comment ) ")"
  ctext           = <any TEXT excluding "(" and ")">
```

<br>

### 4.1.18. 프로토콜별 메타 변수

- 서버는 요청의 프로토콜과 스키마에 특정한 메타 변수를 설정해야 합니다. 
- 프로토콜별 변수의 해석은 SERVER_PROTOCOL의 프로토콜 버전에 따라 달라집니다. 
- 서버는 스키마가 프로토콜과 다른 경우 스키마의 이름을 NULL이 아닌 값으로 설정할 수 있습니다. 
- 이러한 변수의 존재는 스크립트에 요청에서 사용된 스키마를 알려줍니다.

- "HTTP_"로 시작하는 메타 변수는 프로토콜이 HTTP인 경우 클라이언트 요청 헤더 필드에서 읽은 값을 포함합니다. 
- HTTP 헤더 필드 이름은 대문자로 변환되고, "-"의 모든 발생을 ""로 바꾸고, "HTTP"가 메타 변수 이름 앞에 추가됩니다. 
- 헤더 데이터는 클라이언트가 보낸 대로 제공될 수도 있고 의미를 변경하지 않는 방식으로 다시 작성될 수도 있습니다. 
- `동일한 필드 이름을 가진 여러 헤더 필드를 수신하는 경우 서버는 그들을 의미가 동일한 단일 값으로 재작성`해야 합니다. 
- 마찬가지로 여러 줄에 걸친 헤더 필드는 단일 줄로 병합되어야 합니다. 
- 필요한 경우 서버는 데이터의 표현 (예: 문자 집합)을 CGI 메타 변수에 적합한 형식으로 변경해야 합니다.



- 서버는 받은 모든 헤더 필드에 대해 메타 변수를 생성할 필요가 없습니다. 
- 특히 'Authorization'와 같은 인증 정보를 전달하는 헤더 필드나 'Content-Length'와 'Content-Type'과 같이 다른 변수에서 스크립트에서 사용 가능한 헤더 필드를 제거해야 합니다. 
- 서버는 'Connection'과 같이 클라이언트 측 통신 문제와 관련된 헤더 필드를 제거할 수 있습니다.

<br>

## 4.2. 요청 메시지 본문

- 요청 데이터는 시스템에서 정의한 방법으로 스크립트에 의해 액세스됩니다. 기본적으로 '표준 입력' 파일 설명자 또는 파일 핸들을 읽는 것입니다.

```
  Request-Data   = [ request-body ] [ extension-data ]
  request-body   = <CONTENT_LENGTH>OCTET
  extension-data = *OCTET
  ```

- CONTENT_LENGTH가 NULL이 아닌 경우 요청 본문이 요청과 함께 제공됩니다. 
- 서버는 스크립트가 읽을 수 있도록 최소한 그만큼의 바이트를 제공해야 합니다. 
- CONTENT_LENGTH 바이트를 읽은 후 파일의 끝을 나타내는 신호를 전달할 수도 있으며 확장 데이터를 제공할 수도 있습니다. 
- 따라서 스크립트는 더 많은 데이터가 있는 경우에도 CONTENT_LENGTH 바이트를 초과하여 읽어서는 안 됩니다. 
- 그러나 데이터를 읽는 것은 필수적이지 않습니다.

- 비구문화된 헤더 (NPH) 스크립트 (5절 참조)의 경우 서버는 스크립트에 제공되는 데이터가 클라이언트에서 제공한 대로이며 서버에 의해 변경되지 않은 것을 보장해야 합니다.

- 전송 인코딩은 요청 본문에서 지원되지 않으므로 서버는 메시지 본문에서 해당 인코딩을 제거하고 CONTENT_LENGTH를 다시 계산해야 합니다. 
- 이를 수행할 수 없는 경우 (예: 대규모 버퍼링 요구로 인해) 서버는 클라이언트 요청을 거부해야 합니다. 
- 또한 서버는 메시지 본문에서 콘텐츠 인코딩을 제거할 수도 있습니다.

<br>
<br>

## 4.3. 요청 메소드

- REQUEST_METHOD 메타 변수로 제공되는 요청 메소드는 스크립트가 응답을 생성하는 데 적용해야 하는 처리 방법을 식별합니다. 
- 스크립트 작성자는 특정 응용 프로그램에 가장 적합한 메소드를 구현할 수 있습니다. 
- 스크립트가 지원하지 않는 메소드로 요청을 받으면 오류로 거부해야 합니다 (6.3.3절 참조).

<br>

### 4.3.1. GET

- GET 메소드는 메타 변수 값을 기반으로 문서를 생성해야 함을 나타냅니다. 
- 관례적으로 GET 메소드는 '안전(safe)'하고 '멱등(idempotent)'하며 문서 생성 이외의 동작을 갖지 않는 것으로 간주됩니다.

- GET 메소드의 의미는 프로토콜별 메타 변수에 의해 수정 및 정확화될 수 있습니다.

<br>

### 4.3.2. POST

- POST 메소드는 요청 메시지 본문의 데이터를 기반으로 스크립트가 처리를 수행하고 문서를 생성하도록 요청합니다. 
- 일반적으로 HTML [18]의 양식 제출에 사용되며, 데이터베이스 등에 영구적인 영향을 주는 스크립트 처리를 시작하는 데 사용됩니다.

- 스크립트는 첨부된 메시지 본문을 읽기 전에 CONTENT_LENGTH 변수의 값을 확인하고 처리하기 전에 CONTENT_TYPE 값을 확인해야 합니다.

<br>

### 4.3.3. HEAD

- HEAD 메소드는 스크립트가 응답 헤더 필드를 반환할 충분한 처리를 수행하도록 요청합니다. 
- 스크립트는 HEAD 요청에 대해 응답 메시지 본문을 제공해서는 안 됩니다. 
- 그렇게 할 경우 서버는 스크립트에서 응답을 읽을 때 메시지 본문을 폐기해야 합니다.

<br>

### 4.3.4. 프로토콜별 메소드

- 스크립트는 HTTP/1.1 PUT 및 DELETE와 같은 프로토콜별 메소드를 구현할 수 있습니다. 이 경우 SERVER_PROTOCOL의 값을 확인해야 합니다.

- 서버는 일부 메소드가 스크립트에 적합하지 않거나 허용되지 않을 수 있으며, 해당 메소드를 직접 처리하거나 클라이언트에게 오류를 반환할 수 있습니다.

<br>

### 4.4. 스크립트 명령줄

- 일부 시스템은 CGI 스크립트에 문자열 배열을 제공하는 방법을 지원합니다. 
- 이는 '=' 문자가 인코딩되지 않은 URI 쿼리 문자열을 포함하지 않는 '색인화된' HTTP 쿼리의 경우에만 사용됩니다. 
- 이러한 요청에 대해 서버는 쿼리 문자열을 검색 문자열로 취급하고, 규칙을 사용하여 단어로 구문 분석한 후, 각 검색 단어를 URL 디코딩한 다음 시스템에 정의된 방식으로 선택적으로 인코딩하고 명령줄 인수 목록에 추가해야 합니다.

- 서버가 인수 목록의 일부를 생성할 수 없는 경우, 서버는 명령줄 정보를 생성해서는 안 됩니다. 
- 예를 들어, 인수의 수가 운영 체제나 서버 제한보다 많을 수 있거나, 단어 중 하나가 인수로 표현될 수 없을 수 있습니다.

- 스크립트는 QUERY_STRING 값에 인코딩되지 않은 '=' 문자가 있는지 확인하고, 있다면 명령줄 인수를 사용해서는 안 됩니다.

<br><br>

# 5. NPH 스크립트
## 5.1. 식별

- 서버는 NPH (Non-Parsed Header) 스크립트를 지원할 수 있습니다. 
- 이는 서버가 응답 처리에 대한 모든 책임을 스크립트에게 전달하는 스크립트입니다.

- 이 명세서는 NPH 스크립트를 출력 데이터만으로 식별하기 위한 메커니즘을 제공하지 않습니다. 
- 따라서 특정 스크립트는 NPH 또는 CGI 중 하나의 출력만 제공할 수 있으며, 따라서 스크립트 자체는 'NPH 스크립트'로 설명됩니다. 
- NPH 지원을 갖춘 서버는 NPH 스크립트를 식별하기 위한 구현 정의된 메커니즘을 제공해야 할 수 있으며, 이는 스크립트의 이름이나 위치를 기반으로 할 수 있습니다.

<br>

## 5.2. NPH 응답

- 스크립트가 서버 또는 클라이언트에게 데이터를 보낼 수 있는 시스템 정의된 방법이 있어야 합니다. 
- 스크립트는 항상 일부 데이터를 반환해야 합니다. 
- 정의되지 않은 경우에는 전통적인 CGI 스크립트와 동일합니다.

- 현재 NPH 스크립트는 HTTP 클라이언트 요청에 대해서만 정의되어 있습니다. 
- (HTTP) NPH 스크립트는 현재 HTTP 사양 [1], [4]의 6절에서 설명되는 완전한 HTTP 응답 메시지를 반환해야 합니다. 
- 스크립트는 SERVER_PROTOCOL 변수를 사용하여 응답에 적합한 형식을 결정해야 합니다. 
- 특정 프로토콜 사양에서 요구하는 일반적인 또는 프로토콜별 메타 변수를 고려해야 합니다.

- 서버는 스크립트 출력이 수정되지 않고 클라이언트로 전송되도록 보장해야 합니다. 
- 이는 스크립트가 헤더 필드에서 올바른 문자 집합 (HTTP의 US-ASCII [9] 및 ISO 8859-1 [10])을 사용해야 함을 의미합니다. 
- 서버는 스크립트 출력이 최소한의 내부 버퍼링과 전송 가능한 버퍼링 없이 직접 클라이언트로 전송되도록 노력해야 합니다.

- 구현에 따라 스크립트는 응답에서 클라이언트가 동일한 연결을 통해 추가 요청을 보낼 수 있다는 것을 나타내어서는 안 됩니다.

<br><br>


# 6.CGI 응답

## 6.1. 응답 처리

- 스크립트는 항상 비어있지 않은 응답을 제공해야 하므로, 이를 서버로 다시 보내기 위한 시스템 정의된 방법이 있어야 합니다. 
- 명시적으로 정의되지 않은 경우, 이는 '표준 출력' 파일 기술자를 통해 이루어집니다.

- 스크립트는 요청을 처리하고 응답을 준비할 때 REQUEST_METHOD 변수를 확인해야 합니다.

- 서버는 스크립트로부터 데이터를 수신해야 하는 시간 제한 기간을 구현할 수 있습니다. 
- 이러한 시간 제한을 정의한 서버 구현이 있고 제한 기간 내에 스크립트로부터 데이터를 수신하지 못한 경우, 서버는 스크립트 프로세스를 종료할 수 있습니다.

<br>

## 6.2. 응답 유형

- 응답은 메시지 헤더와 메시지 본문으로 구성되며, 이들은 빈 줄로 구분됩니다. 
- 메시지 헤더는 하나 이상의 헤더 필드를 포함하고 있습니다. 
- 본문은 NULL일 수 있습니다.

```
generic-response = 1*header-field NL [ response-body ]
```

- 스크립트는 문서 응답, 로컬 리디렉션 응답 또는 클라이언트 리디렉션 (선택적인 문서 포함) 응답 중 하나를 반환해야 합니다. 
- 아래에 정의된 응답에서 응답의 헤더 필드의 순서는 중요하지 않습니다 (BNF에 나와 있는 것과 달리). 헤더 필드는 6.3절에서 정의되어 있습니다.

```
  CGI-Response = document-response | local-redir-response |
                 client-redir-response | client-redirdoc-response
```

<br>

## 6.2.1. 문서 응답

- CGI 스크립트는 문서 응답에서 사용자에게 문서를 반환할 수 있으며, 선택적인 오류 코드를 통해 응답의 성공 상태를 나타낼 수 있습니다.

```
document-response = Content-Type [ Status ] *other-field NL
                      response-body
```

- 스크립트는 Content-Type 헤더 필드를 반환해야 합니다. 
- Status 헤더 필드는 선택적이며, 생략된 경우 상태 200 'OK'로 가정됩니다. 
- 서버는 스크립트의 출력을 적절하게 수정하여 클라이언트에 대한 응답이 응답 프로토콜 버전과 일치하도록 해야 합니다.

<br>

## 6.2.2. 로컬 리디렉션 응답

- CGI 스크립트는 Location 헤더 필드에 로컬 리소스를 위한 URI 경로와 쿼리 문자열 ('local-pathquery')을 반환하여 서버에게 해당 경로를 사용하여 요청을 다시 처리해야 함을 알릴 수 있습니다.

```
  local-redir-response = local-Location NL
```

- 스크립트는 다른 헤더 필드나 메시지 본문을 반환해서는 안 되며, 서버는 다음 URL을 포함하는 요청에 대한 응답을 생성해야 합니다.

```
  scheme "://" server-name ":" server-port local-pathquery
```

<br>

### 6.2.3. 클라이언트 리디렉션 응답

- CGI 스크립트는 Location 헤더 필드에 절대 URI 경로를 반환하여 클라이언트에게 지정된 URI를 사용하여 요청을 다시 처리해야 함을 알릴 수 있습니다.

```
  client-redir-response = client-Location *extension-field NL
```

- 스크립트는 서버에서 정의한 CGI 확장 필드를 제외하고 다른 헤더 필드를 제공해서는 안 됩니다. 
- HTTP 클라이언트 요청의 경우, 서버는 302 'Found' HTTP 응답 메시지를 생성해야 합니다.

<br>

### 6.2.4. 문서를 포함한 클라이언트 리디렉션 응답

- CGI 스크립트는 Location 헤더 필드에 절대 URI 경로와 함께 첨부된 문서를 반환하여 클라이언트에게 지정된 URI를 사용하여 요청을 다시 처리해야 함을 알릴 수 있습니다.

```
client-redirdoc-response = client-Location Status Content-Type
                             *other-field NL response-body
```

- Status 헤더 필드는 제공되어야 하며, 상태 값으로 302 'Found'를 포함해야 합니다. 
- 또는 확장 코드, 즉 클라이언트 리디렉션을 의미하는 다른 유효한 상태 코드를 포함할 수 있습니다. 
- 서버는 스크립트의 출력을 적절하게 수정하여 클라이언트에 대한 응답이 응답 프로토콜 버전과 일치하도록 해야 합니다.

<br>

## 6.3. 응답 헤더 필드

- 응답 헤더 필드는 서버에 의해 해석되는 CGI 필드 또는 확장 헤더 필드이거나, 클라이언트에 반환되는 프로토콜별 헤더 필드입니다. 
- 적어도 하나의 CGI 필드가 제공되어야 하며, 각 CGI 필드는 응답에서 한 번만 나타날 수 있습니다. 
- 응답 헤더 필드는 다음과 같은 구문을 가집니다.

```
  header-field    = CGI-field | other-field
  CGI-field       = Content-Type | Location | Status
  other-field     = protocol-field | extension-field
  protocol-field  = generic-field
  extension-field = generic-field
  generic-field   = field-name ":" [ field-value ] NL
  field-name      = token
  field-value     = *( field-content | LWSP )
  field-content   = *( token | separator | quoted-string )
```

- field-name은 대소문자를 구분하지 않습니다. 
- NULL 필드 값은 필드를 전송하지 않은 것과 동등합니다. 
- 각 CGI-응답의 헤더 필드는 한 줄에 명시되어야 하며, CGI/1.1은 연속되는 줄을 지원하지 않습니다. 
- ":"와 field-value 사이에 공백을 허용하며 (field-name과 ":" 사이에 공백은 허용하지 않음), field-value 내의 토큰 사이에도 공백을 허용합니다.

<br>

### 6.3.1. Content-Type

- Content-Type 응답 필드는 개체 본문의 인터넷 미디어 유형 [6]을 설정합니다.

````
  Content-Type = "Content-Type:" media-type NL
```

- 개체 본문이 반환되는 경우, 스크립트는 응답에 Content-Type 필드를 제공해야 합니다. 
- 이를 제공하지 않은 경우 서버는 올바른 콘텐츠 유형을 결정하지 않아야 합니다. 
- 값은 문자 집합 매개 변수 변경을 제외하고 그대로 클라이언트에게 전송되어야 합니다.

- 텍스트 미디어 유형에 대해 HTTP 프로토콜의 경우 클라이언트가 가정하는 기본 문자 집합은 ISO-8859-1이며, 그렇지 않은 경우 US-ASCII입니다. 
- 따라서 스크립트는 문자 집합 매개 변수를 포함해야 합니다. 
- 이 문제에 대한 자세한 내용은 HTTP/1.1 사양의 3.4.1절을 참조하십시오.

<br>

### 6.3.2. Location

- Location 헤더 필드는 스크립트가 실제 문서가 아닌 문서에 대한 참조를 반환하고 있다는 것을 서버에 지정하는 데 사용됩니다 (6.2.3절과 6.2.4절 참조). 
- 절대 URI (선택적으로 프래그먼트 식별자를 포함)를 사용하여 클라이언트가 참조된 문서를 가져와야 함을 나타내거나, 로컬 URI 경로 (선택적으로 쿼리 문자열과 함께)를 사용하여 서버가 참조된 문서를 가져와서 응답으로 클라이언트에게 반환해야 함을 나타냅니다.

```
  Location        = local-Location | client-Location
  client-Location = "Location:" fragment-URI NL
  local-Location  = "Location:" local-pathquery NL
  fragment-URI    = absoluteURI [ "#" fragment ]
  fragment        = *uric
  local-pathquery = abs-path [ "?" query-string ]
  abs-path        = "/" path-segments
  path-segments   = segment *( "/" segment )
  segment         = *pchar
  pchar           = unreserved | escaped | extra
  extra           = ":" | "@" | "&" | "=" | "+" | "$" | ","
```

- 절대URI의 구문은 이 문서에서 RFC 2396 [2]과 RFC 2732 [7]에 지정된 구문으로부터 통합되었습니다. 
- 유효한 절대URI는 항상 scheme 이름으로 시작하여 ":"으로 끝납니다. 
- scheme 이름은 문자로 시작하고 문자, 숫자, "+", "-", "."으로 이어집니다. 
- 로컬 URI 경로와 쿼리는 절대 경로이어야 하며, 상대 경로나 NULL이면 안 되므로 "/"로 시작해야 합니다.

- 참고로 요청에 첨부된 메시지 본문 (POST 요청의 경우)은 리디렉션 대상이 되는 리소스에서 사용할 수 없습니다.

<br><br>

# 7. 시스템 사양

## 7.1. AmigaDOS

- 메타 변수
- 메타 변수는 동일한 이름의 환경 변수로 스크립트에 전달됩니다. 
- 이는 DOS 라이브러리 루틴인 GetVar()을 통해 액세스됩니다. 
- flags 인수는 0이어야 합니다. 
- 대소문자는 무시되지만 대문자는 대소문자 구분 시스템과의 호환성을 위해 권장됩니다.

<br>

- 현재 작업 디렉토리
- 스크립트의 현재 작업 디렉토리는 스크립트를 포함하는 디렉토리로 설정됩니다.

<br>

- 문자 집합
- US-ASCII 문자 집합 [9]은 메타 변수, 헤더 필드 및 값의 정의에 사용됩니다. 
- 새 줄 (NL) 시퀀스는 LF입니다. 
- 서버는 CR LF를 줄 바꿈으로도 인식해야 합니다.

<br>

## 7.2. UNIX

- UNIX 호환 운영 체제에 대해 다음이 정의됩니다.

- 메타 변수
- 메타 변수는 동일한 이름의 환경 변수로 스크립트에 전달됩니다. 이는 C 라이브러리 루틴인 getenv() 또는 변수 environ을 통해 액세스됩니다.

<br>

- 명령 줄
- 이는 main()에 대한 argc 및 argv 인수를 사용하여 액세스됩니다. 단어에는 Bourne 셸에서 '활성'인 모든 문자가 백슬래시로 이스케이프 처리됩니다.

<br>

- 현재 작업 디렉토리
- 스크립트의 현재 작업 디렉토리는 스크립트를 포함하는 디렉토리로 설정되어야 합니다.

<br>

- 문자 집합
- US-ASCII 문자 집합 [9] 중 NUL을 제외한 문자가 메타 변수, 헤더 필드 및 CHAR 값의 정의에 사용됩니다. 
- TEXT 값은 ISO-8859-1을 사용합니다. 
- PATH_TRANSLATED 값에는 NUL을 제외한 모든 8비트 바이트가 포함될 수 있습니다. 
- 새 줄 (NL) 시퀀스는 LF입니다. 
- 서버는 CR LF를 줄 바꿈으로도 인식해야 합니다.

<br>

## 7.3. EBCDIC/POSIX

- EBCDIC 문자 집합을 사용하는 POSIX 호환 운영 체제에 대해 다음이 정의됩니다.

- 메타 변수
- 메타 변수는 동일한 이름의 환경 변수로 스크립트에 전달됩니다. 
- 이는 C 라이브러리 루틴인 getenv()을 통해 액세스됩니다.

- 명령 줄
- 이는 main()에 대한 argc 및 argv 인수를 사용하여 액세스됩니다. 
- 단어에는 Bourne 셸에서 '활성'인 모든 문자가 백슬래시로 이스케이프 처리됩니다.

- 현재 작업 디렉토리
- 스크립트의 현재 작업 디렉토리는 스크립트를 포함하는 디렉토리로 설정되어야 합니다.

- 문자 집합
- IBM1047 문자 집합 [21] 중 NUL을 제외한 문자가 메타 변수, 헤더 필드, 값, TEXT 문자열 및 PATH_TRANSLATED 값의 정의에 사용됩니다. 
- 새 줄 (NL) 시퀀스는 LF입니다. 
- 서버는 CR LF를 줄 바꿈으로도 인식해야 합니다.

- 미디어 타입 문자 집합 기본값
- 텍스트 (및 기타 구현 정의) 미디어 유형의 기본 문자 집합 값은 IBM1047입니다.

<br><br>

# 8. 구현

## 8.1. 서버에 대한 권장 사항

- 서버와 CGI 스크립트는 URL 경로 처리 (클라이언트 URL 및 PATH_INFO 데이터)에서 일관성을 유지할 필요는 없지만, 서버 개발자는 일관성을 유지할 수 있습니다. 
- 따라서 서버 구현은 다음 경우에 대한 동작을 지정해야 합니다.

```
  1. 허용된 경로 세그먼트에 대한 제한 사항을 정의하고, 특히 비종단 NULL 세그먼트가 허용되는지 여부를 지정합니다.

  2. "." 또는 ".." 경로 세그먼트에 대한 동작을 정의합니다.  
  즉, 이러한 세그먼트가 금지되는지, 일반적인 경로 세그먼트로 처리되는지 아니면 상대 URL 사양 [2]에 따라 해석되는지 여부를 지정합니다.

  3. 경로 또는 검색 문자열 길이에 대한 제한, 서버가 구문 분석할 헤더 필드의 양에 대한 제한을 포함하여 구현의 제한 사항을 정의합니다.
```

<br>

## 8.2. 스크립트에 대한 권장 사항

- 스크립트가 PATH_INFO 데이터를 처리하지 않을 경우, PATH_INFO가 NULL이 아닌 경우 404 Not Found로 요청을 거부해야 합니다.


- 양식의 출력이 처리되는 경우, CONTENT_TYPE이 "application/x-www-form-urlencoded" [18] 또는 "multipart/form-data" [16]인지 확인해야 합니다. 
- CONTENT_TYPE이 비어 있는 경우, 스크립트는 프로토콜에서 지원하는 경우 415 'Unsupported Media Type' 오류로 요청을 거부할 수 있습니다.


- PATH_INFO, PATH_TRANSLATED 또는 SCRIPT_NAME을 구문 분석할 때, 스크립트는 비어 있는 경로 세그먼트 ("//")와 특수 경로 세그먼트 (".", "..")에 주의해야 합니다.
- 이들은 OS 시스템 호출에서 사용하기 전에 경로에서 제거되거나 요청이 404 'Not Found'로 거부되어야 합니다.


- 헤더 필드를 반환할 때, 스크립트는 가능한 한 빨리 CGI 헤더 필드를 보내고 HTTP 헤더 필드보다 먼저 보내야 합니다. 
- 이는 서버의 메모리 요구 사항을 줄일 수 있는 도움이 될 수 있습니다.


- 스크립트 작성자는 REMOTE_ADDR 및 REMOTE_HOST 메타 변수 (섹션 4.1.8 및 4.1.9 참조)가 요청의 최종 소스를 식별하지 않을 수 있다는 사실을 인식해야 합니다. 
- 이들은 서버에 대한 즉시 요청의 클라이언트를 식별합니다. 
- 해당 클라이언트는 실제 소스 클라이언트를 대신하여 동작하는 프록시, 게이트웨이 또는 기타 중개자일 수 있습니다.

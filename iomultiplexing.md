# I/O 멀티플렉싱

## CPU와 I/O 하드웨어 사이 작업

- 오늘날 운영체제의 I/O요청은 대부분 비동기적으로 처리된다.
- 이러한 비동기처리는 `인터럽트`라는 하드웨어 매커니즘을 통해 구현된다.
- 1. 장치드라이버(커널)에서 입출력 개시
  - CPU는 매 명령 수행 후, `Interrupt Request Line`에서 인터럽트를 검사.
- 2. 입출력 컨트롤러가 입출력 개시
- 3. 입출력 컨트롤러의 I/O가 완료되면 인터럽트 신호를 생성
- 4. CPU가 인터럽트를 받고, 레지스터, 상태정보 저장 후 제어를 인터럽트 핸들러로 전달.
- 5. 인터럽트 핸들러가 데이터 처리 후, 인터럽트로부터 복귀
- 6. CPU가 이전의 레지스터, 상태정보를 다시 load하고 이 태스크 재시작

- I/O작업뿐만아니라, 네트워크입출력 등이 이러한 작업을 커널단에서 계속 수행한다.

<br><br>

## block-nonblock, sync-async

- 이 두 개념은 각 개념의 관점을 숙지해야한다.
- `blocking은 제어권이 호출스레드`에 있는가 아닌가에 대한 관점
- `sync-async는 제어권이 반환되는 시간과 결과값 반환되는 시간이 동일한가, 다른가`에대한 관점

<br><br>

## blocking vs non-blocking

- blocking system call을 하게되면, 호출 스레드는 blocked 상태가 되며 운영체제가 이 스레드를 waiting queue로 옮긴다.
- 입출력 장치에 의해 수행되는 작업은 비동기적으로 수행시간이 다양하지만, 위에서처럼 입출력장치에서 I/O가 끝나고 인터럽트 신호가 생성되면, CPU가 Interrupt Request Line에서 인터럽트를 확인하면 제어를 인터럽트 핸들러로 전달하고, 데이터를 처리 후 복귀하게된다. 이 인터럽트 핸들러에서 waiting queue에 있던 blocked된 스레드가 다시 ready queue로 돌아가게된다.

- 입출력 장치에 의해 비동기적으로 처리되는 I/O작업의 수행시간은 다양하며 예측하기 어렵지만, blocking 코드가 작성하기 쉽기때문에 현대 운영체제는 API로 blocking system call을 제공한다.

- non-blocking 입출력은 현대 프로그램에 중요한 역할을 하는데, 예를 들어, 동영상 프로그램처럼, 한쪽에서는 disk에서 파일을 읽어오면서 다른쪽에서는 스크린 출력을 동시에 하는 것.
- non-blocking i/o system call은 호출자의 제어권을 그대로 두면서 몇 개의 byte가 준비되었는지 리턴값을 준다.

<br>

### non-blocking i/o 구현

- 제어권이 호출자에게 있으며, 이 non-blocking i/o에는 다양한 방식의 구현이 있다.
- 호출자의 입장에서, 각 I/O요청이 완료되었는지 확인하기위해선 각 I/O 작업이 끝났는지 확인해야하는 `polling`을 수행해야하기때문에 cpu cycle을 낭비한다는 단점이 있다.
- 그래서 이 non-blocking i/o를 구현하는 아래 시스템콜들에는 각각 `timeout`을 설정해 polling의 대기시간을 결정한다.

1. select

- fd set에 대해 모두 순회하면서 각 fd에서 I/O 이벤트 여부 확인, fd많은경우 느림

2. poll

- fd array에 대해 fd에 대한 I/O이벤트 여부 검사. select 보단 빠름

3. epoll

- linux에서 주로 사용된다.
- 이벤트 발생시점에서만 호출, 해당 이벤트가 발생한 fd만 검사.
- fd 수와는 관계없이 일정한 속도로 동작.
- 많은 수의 fd를 처리할때 높은 성능, 대규모 서버, 네트워크 어플리케이션에 주로 사용.

4. kqueue

- FreeBSD, macOS에서 사용된다.
- macOS의 커널은 대부분 kqueue를 사용해 다양한 이벤트를 처리한다.
- kevent 구조체를 사용해 이벤트를 등록하고, 이벤트가 발생하면 등록된 이벤트들을 검사한다.
- kqueue는 파일디스크립터 외에도 프로세스, timer, signal등 다양한 이벤트를 처리할 수 있다.

- webserv는 서버 어플리케이션, macos에서 동작하므로, kqueue을 사용하는 것이 옳다고 사려된다.

<br>
<br>

## asynchronous i/o

- 동기- 비동기 입출력의 구분은 `제어권 반환시간과 결과값 반환시간`이 동일한가 다른가였다.
- non blocking처럼 호출자의 제어권을 그대로 내비두지만, 입출력 종료의 확인은 운영체제가 변수세팅, 소프트웨어 인터럽트인 시그널, 콜백루틴 등을 통해 호출자에게 알려준다.
- non blocking i/o와의 차이점은 non blocking i/o은 호출자에게 non-blocking i/o를 요청한 순간, 일부이든, 전체이든 바로 리턴해준다는 것이며, asynchronous i/o는 미래에 종료될 작업에 대한 요청이다.

- javascript에서 사용되는 async, await의 개념이 여기서 사용된다.
- async함수, 비동기 함수의 의미가 `제어권 반환 시간과 결과값 반환 시간이 다르다`라고 생각했을때,
- await은 이 제어권 반환시간과 결과값 반환시간을 맞춘다는 의미이다.
